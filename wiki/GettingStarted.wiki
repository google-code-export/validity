#summary Quick, simple example of how to get jQuery.validity up and running.

= Requirements =

_Validity_ requires very little setting up to get it running. In order to walk through what we'll need to do we start with a simple HTML document with a basic form.

{{{
<html>
  <head>
    <title>example</title>
  </head>
  <body>
    <form method="get" action="example.htm">
      Enter a number:
      <input type="text" id="number" name="number" />
      <br />
      Also, a date:
      <input type="text" id="date" name="date" />
      <br />
      <input type="submit" />
    </form>
  </body>
</html>
}}}

As _validity_ is a jQuery plugin we will, of course need to load the core jQuery script. Additionally we import the jquery.validity.js script and a set of CSS styles. _validity_ ships with a template CSS file that has basic styles. In this case, for simplicity's sake, we will merely import that template.

Our document now becomes:

{{{
<html>
  <head>
    <title>example</title>
    <link type="text/css" rel="Stylesheet" href="jquery.validity.css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="jquery.validity.js"></script>
  </head>
  <body>
    <form method="get" action="example.htm">
      Enter a number:
      <input type="text" id="number" name="number" />
      <br />
      Also, a date:
      <input type="text" id="date" name="date" />
      <br />
      <input type="submit" />
    </form>
  </body>
</html>
}}}

At this point, the document has everything it needs to make use of _validity_. The only remaining thing to do is configure how the validation is to be performed.

= Validators =

The various validators are covered more extensively in other articles, but for now, let's examine how we are able to configure them to work. We will add a new `script` element wherein we call the `validity` function on a jQuery object representing a `form`. Observe:

{{{
<html>
  <head>
    <title>example</title>
    <link type="text/css" rel="Stylesheet" href="jquery.validity.css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="jquery.validity.js"></script>
    <script type="text/javascript">
      $(function() {        // Wire a function to be called when the page is fully loaded: 
        $("form").validity( // Configure the validation of the form:
          function() { 

                            // This is where the validator logic will go.

          }
        );
      });
    </script>
  </head>
  <body>
    <form method="get" action="example.htm">
      Enter a number:
      <input type="text" id="number" name="number" />
      <br />
      Also, a date:
      <input type="text" id="date" name="date" />
      <br />
      <input type="submit" />
    </form>
  </body>
</html>
}}}

The basic procedure of what's happening in this new `script` element is:
  * We instruct jQuery to execute a function when the DOM has been competed with `$(function() {`. This ensures that the `form` tag will have been loaded by the time we configure the way it will be validated. (`$(function() { /*...*/ });` is a shorter syntax for the older `$(document).ready(function() { /*...*/ });` syntax in jQuery.)
  * We selected the `form` on the page with the code `$('form')`.
  * We call the `validity` method, passing in a function that will contain the meat of our _validity_ configuration.

Let's think about how this form should be validated. First of all, both fields should be required before the form is submitted. After that, we want to make sure that they are both in the right format: the first field must be in the format of a number, and the second in the format of a date. The important thing is that we want to require the fields first, then check format only if the fields have values (i.e. only check the format if the requirement validator _succeeds_). This dynamic is accomplished with jQuery's chaining pattern.

Without going into any details of the validator's method signatures, here's the code that will make it work.

{{{
<html>
  <head>
    <title>example</title>
    <link type="text/css" rel="Stylesheet" href="jquery.validity.css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="jquery.validity.js"></script>
    <script type="text/javascript">
      $(function() {
        $("form").validity(
          function() { 
            $("#number").require().match("number"); // Validation for the 'number' input.
            
            $("#date").require().match("date");     // Validation for the 'date' input.
          }
        );
      });
    </script>
  </head>
  <body>
    <form method="get" action="example.htm">
      Enter a number:
      <input type="text" id="number" name="number" />
      <br />
      Also, a date:
      <input type="text" id="date" name="date" />
      <br />
      <input type="submit" />
    </form>
  </body>
</html>
}}}

As you can see, we've added two lines to our `script` element. Let's look at the first new line. We start by finding the input with the jQuery selector engine: `$("#number")` and then call the `require` method on it. If the `require` method is called on an element inside this function and fails (i.e. if that element turns out to not have a value) then the form submission will ultimately fail.

After the `require` method, we call `match` on its result. The `match` method is used to validate that values correspond to whatever format. In this case we are passing in the string `"number"`, which specifies that the element's value must be a parseable number.

The position of the `match` method is significant. The syntax resembles jQuery's chaining pattern, but has a subtle, yet essential difference. Since it is being called on the result of the `require` method it _will not be executed_ if the `require` fails. This is desirable because we don't care about format if there is no value. If we were to call `match` and then `require` we would be testing format of the value before we've tested that the value exists - and the user would not receive the most helpful error message.

Technically, what is going on is the `require` method (as will all of the various validator methods) is returning a jQuery object of only those elements it was called on that passed validation. This allows us to string together any number of validation rules on one or more inputs but ordering them in such a way that the more specific rules will not be tested until all of the more essential ones succeed.