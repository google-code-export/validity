<html>
    <head>
        <title>jQuery.validity Guide & Documentation</title>
    </head>
    
    <link rel="stylesheet" type="text/css" href="lib/sty.css" />
    
    <script type="text/javascript" src="../jquery.js"></script>

    <script type="text/javascript" src="lib/prettify.js"></script>
    <script type="text/javascript" src="lib/lang-css.js"></script>
    <link rel="stylesheet" type="text/css" href="lib/prettify.css" />
    <script type="text/javascript">
        $(function() { prettyPrint(); });
    </script>
    
    <script type="text/javascript" src="lib/src.js"></script>
    
    <body>
        <div id="content">
            <img id="logo" src="../validity.logo.png" alt="jQuery.validity" />
            <h1>jQuery.validity Guide & Documentation</h1>
            
            <hr />
            
            <h2>Table of Contents:</h2>
            <ul>
                <li><a href="#Introduction">Introduction</a></li>
                <li><a href="#Setup">Setup</a></li>
                <li><a href="#AssigningValidation">Assigning Validation</a></li>
                <ul>
                    <li><a href="#TheValidityMethod">The Validity Method</a></li>
                    <ul>
                        <li><a href="#UsingAFunctionArgument">Using a Function Argument</a>
                            <ul>
                                <li><a href="#BasicFunctions">Basics</a></li>
                                <li><a href="#UnderstandingChains">Understanding Chains</a></li>
                            </ul>
                        </li>
                        <li><a href="#UsingAStringArgument">Using a String Argument</a></li>
                    </ul>
                    <li><a href="#UsingValidityWithAjax">Using Validity With Ajax</a></li>
                </ul>
                <li><a href="#Validators">Validators</a></li>
                <ul>
                    <li><a href="#CommonValidators">Common Validators</a>
                    <ul>
                        <li><a href="#Require">Require</a></li>
                        <li><a href="#Match">Match</a></li>
                        <li><a href="#Range">Range</a></li>
                        <li><a href="#GreaterThan">Greater Than/Greater Than or Equal To</a></li>
                        <li><a href="#LessThan">Less Than/Less Than or Equal To</a></li>
                        <li><a href="#Length">Max Length/Min Length</a></li>
                        <li><a href="#NonHtml">Non HTML</a></li>
                    </ul>
                    <li><a href="#AggregateValidators">Aggregate Validators</a></li>
                    <ul>
                        <li><a href="#Equal">Equal</a></li>
                        <li><a href="#Distinct">Distinct</a></li>
                        <li><a href="#Sum">Sum/Sum Max/Sum Min</a></li>
                    </ul>
                    <li><a href="#SpecializedValidation">Specialized Validation</a></li>
                    <ul>
                        <li><a href="#Assert">Assert</a></li>
                    </ul>
                </ul>
                <li><a href="#TokenizedMessages">Tokenized Messages</a></li>
                <ul>
                    <li><a href="#UnderstandingTokens">Understanding</a></li>
                    <li><a href="#TokenPractices">Best Practices</a></li>
                </ul>
                <li><a href="#OutputModes">Output Modes</a></li>
                <ul>
                    <li><a href="#Label">Label</a></li>
                    <li><a href="#Modal">Modal</a></li>
                    <li><a href="#Summary">Summary</a></li>
                </ul>
                <li><a href="#CustomizingValidity">Customizing Validity Itself</a></li>
                <ul>
                    <li><a href="#AdaptingCSS">Adapting the CSS</a></li>
                    <li><a href="#EditingMessages">Customizing Messages</a></li>
                    <li><a href="#LanguagePackages">Language Packages/Internationalization</a></li>
                    <li><a href="#ExtendingMatchSupport">Customizing/Extending Match Validator Support</a></li>
                    <li><a href="#CustomOutputMode">Writing a Custom Output Mode</a></li>
                </ul>
            </ul>
            
            <hr />
            
            <h2 id="Introduction">Introduction:</h2>
            <p>
                jQuery.validity is a plugin designed to aid in the configuration of clientside form-validation.
                Validity was concieved with three goals:
            </p>
            <ol>
                <li>
                    <strong>Easy Setup:</strong> Validity employs the principle of <em>Convention Over Configuration</em> to
                    aid in keeping code manageable and semantic. Very little work is required to enable Validity
                    for a page.
                </li>
                <li>
                    <strong>Unobtrusive JavaScript:</strong> Using Validity will have almost no effect on the semantics
                    of your markup. Additionally, Validity will degrade gracefully and leave no residuals in browser
                    environments where JavaScript is disabled or unsupported.
                </li>
                <li>
                    <strong>Customizable Appearence:</strong> Validity is an effort to deliver a solid core-library of 
                    validation tools that can be used in any web-design. Therefore, in order to be truly versatile, Validation logic is separated
                    from the way it displays errors. With Validity, you, the developer, have full control
                    of error handling and adapting it to the design of your page.
                </li>
            </ol>
            <p>
                In style, validity makes use of jQuery's selector engine and follows its pattern of method chaining. 
                If you know jQuery, then learning to use validity will be easy.
            </p>
            
            <hr />
            
            <h2 id="Setup">Setup:</h2>
            <p>
                In order to use Validity on a page, you will need to import the jQuery JavaScript library as well as jQuery.validity itself.
                Additionally, you will need to import the CSS styles for the error handling.
            </p>
            <p>
                As a simple example suppose we start with the following HTML document with a simple form:
            </p>
            <pre class="prettyprint lang-html">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Simple&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form method="get" action="simple.htm"&gt;
            Number of Vehicles:
            &lt;input type="text" id="vehicles" name="vehicles" title="Vehicle Count" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            Date of birth:
            &lt;input type="text" id="dob" name="dob" title="Birthday" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            &lt;input type="submit" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
            </pre>
            <p>
                As you can see, there is no validation logic attached to the form. To import Validity we add the 
                following code to the document's head.
            </p>
            <pre class="prettyprint lang-html">
&lt;link type="text/css" rel="Stylesheet" href="jquery.validity.css" /&gt;

&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jquery.validity.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
    // Select all of the forms on the page (in this case the only one)
    // and call 'validity' on the result.
    $(function() { 
        $("form").validity(function() {
            
        });
    });
&lt;/script&gt;
            </pre>
            <p>
                Once jQuery, jQuery.validity and the validity styles are imported we can specify the validation
                logic using the 'validity' method. Normally, this the 'validity' method is called on 
                jQuery objects of HTML forms and accepts a function as argument. As you can see, in the 
                code above, a jQuery selector finds the form and then the validity method is called with
                an empty anonymous function as argument.
            </p>
            <p>
                Inside the function argument we can specify the validation code.
            </p>
            <p>
                Let's say that we want to require both of the fields. Also, we want to require that the first
                field is in the form of a number between 4 and 12. The second field will need to be a date 
                and that date will have to be before today.
            </p>
            <p>
                Validation methods are covered in greater detail later on in this document, but for now we can
                specify validation with the following calls inside the validity function.
            </p>
            <pre class="prettyprint lang-js">
$("form").validity(function() {
    $("#vehicles")
        .require()
        .match("number")
        .range(4, 12);
    
    $("#dob")
        .require()
        .match("date")
        .lessThanOrEqualTo(new Date());
});
            </pre>
            
            <p>
                Putting it all together, the interactive example below is produced. 
                Click the link to view the complete source code.
            </p>
            
            <div class="ex_w_src">    
                <div>[<a href="#_">View Source</a>]</div>
                <iframe id="setup-iframe" src="lib/simple.htm"></iframe>
                <pre id="setup-src" class="prettyprint lang-html">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Simple&lt;/title&gt;
        &lt;link type="text/css" rel="Stylesheet" href="../../jquery.validity.css" /&gt;
        &lt;script type="text/javascript" src="../../jquery.js"&gt; &lt;/script&gt;
        &lt;script type="text/javascript" src="../../jquery.validity.js"&gt; &lt;/script&gt;
        &lt;script type="text/javascript"&gt;
            $(function() { 
                $("form").validity(function() {
                    $("#vehicles")
                        .require()
                        .match("number")
                        .range(4, 12);
                    
                    $("#dob")
                        .require()
                        .match("date")
                        .lessThanOrEqualTo(new Date());
                });
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form method="get" action="simple.htm"&gt;
            Number of Vehicles:
            &lt;input type="text" id="vehicles" name="vehicles" title="Vehicle Count" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            Date of birth:
            &lt;input type="text" id="dob" name="dob" title="Birthday" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            &lt;input type="submit" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
                </pre>
            </div>
            
            <hr />
            
            <h2 id="AssigningValidation">Assigning Validation:</h2>
            
            <p>
                There are multiple ways to assign validation logic to a form.
                In the 'setup' example the validity method is used with a function
                argument. This method can also be called with a string argument. 
                Furthermore validity can be used without the validity method, for 
                instance, when validating Ajax.
            </p>

            <hr />
            
            <h3 id="TheValidityMethod">The Validity Method</h3>
            
            <p>
                The Validity script defines the validity method on all jQuery objects, however
                it will only effect form elements. You may use it to select one or more forms
                and register the validation for each. There are two argument types that the method
                will accept: a function and a string.
            </p>
            
            <hr />

            
            <h4 id="UsingAFunctionArgument">Using a Function Argument</h4>
            
            <p>
                In almost all cases, as in the setup example, your argument into the validity
                method will be a function. Within the function you will call the validator methods.
            </p>
            
            <p>
                The advantages of using a function argument for validation lie in your ability to 
                make use of JavaScript control structures (i.e. if...else blocks, iterators, etc.) 
                and your access to the full power of the jQuery selector engine.
            </p>
            
            <hr />
            
            <h5 id="BasicFunctions">Basics</h5>
            
            <p>
                A simple validation scenario allows you to simply select individual 
                inputs and setup validation on each. For example:
            </p>
            
            <pre class="prettyprint lang-js">
$('#my-form').validity(function() {
    // Required and has to be a number.
    $("#text-box-one")
        .require()
        .match("number");
    
    // Not required, but it has to be a date
    $("#text-box-two")
        .match("date");
});
            </pre>
            
            <p>
                You may also take advantage of the selector engine and validate several inputs
                with a single statement. For instance, if a page has several inputs that need to 
                represent percentages, and that all need to add up to 100%, then the following
                code may be appropriate.
            </p>
            
            <pre class="prettyprint lang-js">
$('#my-other-form').validity(function() {
    // All of the interesting inputs will be under a percentage class, so:
    $(".percentage")
        .require()          // Each is required 
        .match("number")    // Each must be numeric
        .sum(100);          // The sum of all of them should be 100%.
});
            </pre>
            
            <p>
                Furthermore, you can use JavaScript control structures to conditionally 
                validate. In the following interactive example, an if...then structure 
                is used to require an email input only if the checkbox is checked.
            </p>
            
            <div class="ex_w_src">    
                <div>[<a href="#_">View Source</a>]</div>
                <iframe id="conditional-iframe" src="lib/conditional.htm"></iframe>
                <pre id="conditional-src" class="prettyprint lang-html">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Conditional&lt;/title&gt;
        &lt;link rel="Stylesheet" type="text/css" href="../../jquery.validity.css" /&gt;
        &lt;script type="text/javascript" src="../../jquery.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="../../jquery.validity.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript"&gt;
            $(function() { 
                $("form").validity(function() { 
                    if ($("#maillist").attr("checked")) {
                        $("#email")
                            .require("We'll need #{field} if you want to be on the mailing list.")
                            .match("email");
                    }
                });
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action="conditional.htm" method="get"&gt;
            &lt;input type="checkbox" id="maillist" name="maillist" /&gt;
            
            &lt;label for="maillist"&gt;
                Yes, I'd like to recieve updates: 
            &lt;/label&gt;
            
            &lt;br /&gt;
            
            &lt;label for="email"&gt;
                My email:
            &lt;/label&gt;
            
            &lt;input type="text" id="email" name="email" title="your address" /&gt;
            
            &lt;br /&gt;
            
            &lt;input type="submit" value="Submit" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
                </pre>
            </div>
            
            <hr />
            
            <h5 id="UnderstandingChains">Understanding Chains</h5>
            
            <p>
                You may have noticed that the validator functions can be called on the
                results of other validator methods in the manner of jQuery function chaining.
                For instance:
            </p>
            
            <pre class="prettyprint lang-js">
$("#some_textbox").require().match("number");
            </pre>
            
            <p>
                The basic mechanic involved with chains is that functions later in a chain
                will only do validation if the previous ones succeed. In other words, in the 
                above code snippet, if the input does not have a value (i.e. require() fails)
                then validity is smart enough to not check the format with the match("number")
                call. It would be meaningless to complain about the format if there was no value
                to check.
            </p>
            
            <p>
                In this fashion you can assign the validator methods in the order of <em>most 
                essential first</em>, and then do the more specific calls later.
            </p>
            
            <hr />
            
            <h4 id="UsingAStringArgument">Using a String Argument</h4>
            
            <p>
                In cases when you merely need to require some of the inputs
                on a page and don't need to format-check them, you can merely
                pass a string into the validity method that selects them.
            </p>
            
            <p>
                In the following interactive example, we validate the page
                with the statement: 
            </p>
            
            <pre class="prettyprint">
$("form").validity("input:text, select"); 
            </pre>
            
            <p>
                ...because that string would select all of the inputs we need.
            </p>
            
            <div class="ex_w_src">    
                <div>[<a href="#_">View Source</a>]</div>
                <iframe id="stringargument-iframe" src="lib/stringargument.htm" style="height:200px"></iframe>
                <pre id="stringargument-src" class="prettyprint lang-html">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;String Argument&lt;/title&gt;
        &lt;link type="text/css" rel="Stylesheet" href="../../jquery.validity.css" /&gt;
        &lt;script type="text/javascript" src="../../jquery.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="../../jquery.validity.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript"&gt;
            $(function() { 
                $("form").validity("input:text, select");
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form method="get" action="stringargument.htm"&gt;
            &lt;label for="PetName"&gt;Name of Pet:&lt;/label&gt;
            &lt;input type="text" id="PetName" name="PetName" title="name" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            
            &lt;label for="PetType"&gt;Type of Pet:&lt;/label&gt;
            &lt;select id="PetType" name="PetType" title="type"&gt;
                &lt;option selected="selected"&gt;&lt;/option&gt;
                &lt;option&gt;Dog&lt;/option&gt;
                &lt;option&gt;Cat&lt;/option&gt;
                &lt;option&gt;Bird&lt;/option&gt;
                &lt;option&gt;Lizard&lt;/option&gt;
                &lt;option&gt;Panda&lt;/option&gt;
            &lt;/select&gt;
            &lt;br /&gt;&lt;br /&gt;
            
            &lt;label for="Petfoodbrand"&gt;Brand of Petfood:&lt;/label&gt;
            &lt;input type="text" id="Petfoodbrand" name="Petfoodbrand" title="brand" /&gt;
            &lt;br /&gt;&lt;br /&gt;
            
            &lt;input type="submit" value="Submit" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
                </pre>
            </div>
            
            <p>
                If we wished to make the petfood input optional, we could modify
                the string the same way we'd craft a jQuery selector to exclude this
                input. For example:
            </p>
            
            <pre class="prettyprint lang-js">
$("form").validity("input:text:not(#Petfoodbrand), select");
            </pre>
            
            <hr />
            
            <h3 id="UsingValidityWithAjax">Using Validity with Ajax</h3>
            
            <p>
                If your page uses Ajax and cannot bind to a form in the way described 
                above, or you otherwise wish not to use the validity method, you will
                need to manually call validity's start and end methods.                
            </p>
            
            <p>
                These functions are really quite easy to use.
            </p>
            
            <p>
                Essentially, the start function should be called before any validator 
                methods. The end function should be called after all the validator
                methods have been called, and it returns an object representing the
                results of the validation.
            </p>
            
            <p>
                The result object that is returned by the end function bears two properties.
                'valid' is a boolean representing whether no errors occurred between
                the times that start and end were called. If there were no errors, 'valid' 
                will be 'true'. The other property is 'errors', which is an integer 
                representing how many errors occurred. If 'valid' is 'true' then 'errors' will be '0'.
            </p>
            
            <p>
                For example, a sample function that would validate inputs without 
                a form might look like this:
            </p>
            
            <pre class="prettyprint lang-js">
// This is the validation function:
function validateMyAjaxInputs() {
    // Start validation:
    $.validity.start();
    
    // Validator methods go here:
    
    // For instance:
    $("#my_textbox").require();
    
    // etc.
    
    // All of the validator methods have been called:
    // End the validation session:
    var result = $.validity.end();
    
    // Return whether it's okay to proceed with the Ajax:
    return result.valid;
}

// This is the function wired into the click event of some link or button:
function ajaxButtonClicked() {
    // First check whether the inputs are valid:
    if (validateMyAjaxInputs()) {
        // Do ajax:
        // ...
    }
}
            </pre>
            
            <hr />
            
            <h2 id="Validators">Validators</h2>
            
            <p>
                Validity defines various methods onto jQuery objects for
                validation. We'll call these validator methods.
            </p>
            
            <hr />
            
            <h3 id="CommonValidators">Common Validators</h3>
            
            <p>
                The common validator methods all deal specifically with 
                individual inputs. Any of them can be called on jQuery 
                objects of several inputs. Each input will be validated 
                indivdiually.
            </p>
            
            <p>
                In other words, we could use jQuery several times to select each 
                input and call the 'require' validator method each time. 
                Alternatively, and more elegantly, we could simply select all of 
                the needed inputs and call 'require' once on that.
            </p>
            
            <p>
                Below are summarized the various common validator methods.
            </p>
            
            <hr />
            
            <h4 id="Require">Require:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").require( ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                This is the most basic validation method. It merely checks to ensure that 
                inputs have values. If any do not have a value (i.e. value.length is zero) 
                an error is raised for that input and the form will not be submitted.
            </p>
            
            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Require all inputs, use the default error message.
$("input:text").require();
            </pre>
            
            <pre class="prettyprint lang-js">
// A specific error message is attached to a specific input.
$("#ssn").require("Your Social Security Number is required to proceed.");
            </pre>
            
            <hr />
            
            <h4 id="Match">Match:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").match( 'patternName'|RegExp, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>patternName</code>: 
                    A named pattern to match against. A list of the named formats that are 
                    built into validity can be found below.
                </li>
                <li>
                    <code>RegExp</code>:
                    Instead of a named pattern, you may enter a Regexp object to use for 
                    testing the value. 
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Tests that the inputs conform to the specified format. This is achieved 
                by passing in a Regexp to match the value against. validity also includes 
                several common Regexps that you may use by merely passing in their name 
                as a string.
            </p>
            
            <p>
                The built-in Regexp names are: 
            </p>
            
            <ul>
                <li>
                    <code>'integer'</code>: 
                    Will match only positive, whole numbers.
                </li>
                <li>
                    <code>'date'</code>: 
                    Will only match dates. (Supports all date formats that can be natively 
                    parsed by the <code>Date.parse()</code> function.)
                </li>
                <li>
                    <code>'email'</code>: 
                    Matches email addresses.
                </li>
                <li>
                    <code>'usd'</code>: 
                    Matches U.S. Dollar amounts.
                </li>
                <li>
                    <code>'url'</code>: 
                    Matches web-addresses.
                </li>
                <li>
                    <code>'number'</code>: 
                    Matches a number, be it integer or float, positive or negative or in 
                    scientific-notation.
                </li>
                <li>
                    <code>'zip'</code>: 
                    Matches an U.S. Postal Code (in both 5 and 9 digit forms).
                </li>
                <li>
                    <code>'phone'</code>: 
                    Matches an U.S. Domestic Phone number.
                </li>
            </ul>
            
            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Make sure that all inputs under the 'date' class are 
// properly formatted.(Given they bear a value.) If any 
// fail, they will be tagged with a default error message 
// associated with the 'date' pattern.
$('input.date').match('date');
            </pre>
            
            <pre class="prettyprint lang-js">
// Same as the previous example, but the dates are now required also.
$('input.date')
    .require()
    .match('date');
            </pre>
            
            <pre class="prettyprint lang-js">
// Ensures that an input named 'employeeId' conforms to a 
// special, company-specific pattern, and specifies a 
// helpful message.
$('#employeeId').match(/^\d{2}[-]\d{4}$/, "Employee Ids must be in the form XX-XXXX.");
            </pre>
            
            <hr />
            
            <h4 id="Range">Range:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").range( min, max, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>min</code>: 
                    The <em>inclusive</em> lower-bound for valid values.
                </li>
                <li>
                    <code>max</code>:
                    The <em>inclusive</em> upper-bound for valid values.
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Will restrict the value to an inclusive numeric or date range. The min and max 
                arguments should be either both numeric or both JavaScript date objects.
            </p>
            
            <p>
                Since the range validator expects either numbers or dates you should use range
                after a match validator so that you may be sure that the values which are 
                range-checked will be in a valid format.
            </p>
            
            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Restrict valid values to an inclusive numeric range.
$("#percentage")
    .match(/^\d+\.?\d*%?/, "Must be formatted like a percent.")
    .range(0, 100);
            </pre>
            
            <pre class="prettyprint lang-js">
// Restrict valid values to an inclusive temporal range.
$("#DayDuringClintonAdministration")
    .match('date')
    .range(new Date("01/20/1993"), new Date("01/20/2001"));
            </pre>
            
            <hr />
            
            <h4 id="GreaterThan">Greater Than/Greater Than or Equal To:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").greaterThan( min, ['message'] )</pre>
            <pre>jQuery("selector").greaterThanOrEqualTo( min, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>min</code>: 
                    The lower-bound for valid values.
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Restricts the value to be larger than the specified minimum.
            </p>
            
            <p>
                Since the range validator expects either numbers or dates you should use range
                after a match validator so that you may be sure that the values which are 
                range-checked will be in a valid format.
            </p>
            
            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Validates a cost input, that it must be more than zero.
$("#cost")
    .match("usd")
    .greaterThan(0, "Cost cannot be zero.");
            </pre>

            <pre class="prettyprint lang-js">
// Validates a velocity input, that it must be greater than or equal zero.
$("#velocity")
    .match("number")
    .greaterThanOrEqualTo(0, "You cannot have negative velocity.");
            </pre>
                        
            <hr />
            
            <h4 id="LessThan">Less Than/Less Than or Equal To:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").lessThan( max, ['message'] )</pre>
            <pre>jQuery("selector").lessThanOrEqualTo( max, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>max</code>: 
                    The upper-bound for valid values.
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Restricts the value to be smaller than the specified minimum.
            </p>
            
            <p>
                Since the range validator expects either numbers or dates you should use range
                after a match validator so that you may be sure that the values which are 
                range-checked will be in a valid format.
            </p>
            
            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
$("#angle")
    .match("number")
    .lessThan(180, "Angle cannot be greater than 180 degrees.");
            </pre>
            
            <pre class="prettyprint lang-js">
$("#hoursPerDay")
    .match("integer")
    .lessThanOrEqualTo(24, "Cannot be more than twenty-four.");
            </pre>

            <hr />
            
            <h4 id="Length">Max Length/Min Length:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").maxLength( max, ['message'] )</pre>
            <pre>jQuery("selector").minLength( min, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>max</code>: 
                    The upper-bound for valid values.
                </li>
                <li>
                    <code>min</code>: 
                    The lower-bound for valid values.
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Restricts the length of the value to the specified maximum or minimum. 
                This validator is useful to restrict input values to the max-length 
                allowed by a database schema. 
            </p>

            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
$("textarea#description").maxLength(255);
            </pre>
            
            <pre class="prettyprint lang-js">
$("#detailedExplaination")
    .minLength(1000, "You need to give more detail.");
            </pre>
                        
            <hr />
            
            <h4 id="NonHtml">Non HTML:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").nonHtml( ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Disallows the angle brackets necessary for XSS attacks.
            </p>

            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
$("#myBiography").nonHtml();
            </pre>
            
            <hr />
            
            <h3 id="AggregateValidators">Aggregate Validators</h3>
            
            <p>
                Aggregate validators are able to do validation rules that involve 
                more than one input. In a similar way to how aggregate functions in 
                SQL take several records and gather them into one result, aggregate
                validators can take several HTML elements and determine whether they
                are valid with regard to eachother.
            </p>
            
            <p>
                This feature of validity is where the advantage of building a validation
                framework on top of jQuery is clear.
            </p>
            
            <hr />
            
            <h4 id="Equal">Equal:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").equal( [transform], ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>transform</code>:  
                    Optional transform to apply to each value before testing. 
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Ensure that the values of all matched elements are equal to each other. 
                This is an aggregate validator, meaning that it should be applied to 
                groups of inputs. A common use for the equal validator is in 
                password-confirmation scenarios, where a form should not be submitted if 
                a user fails to reenter his or her password correctly. 
            </p>

            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Write a jQuery selector that results in both the password and its confirmation,
// then validate it with 'equal'.
$("text[type='password']")
    .match(mySpecialPasswordRegex, myPasswordFormatMessage)
    .equal("Passwords do not match.");
            </pre>
            
            <pre class="prettyprint lang-js">
// We can also extract the important part of a value, and test the equality only on that.
// For instance, we might want phone numbers to be equal disregarding whether they
// use '.' or '-' to separate groups, or have the area code in parentheses.
$("input.phone")
    .match("phone")
    .equal(
        function(val) { 
            return val.replace(/[-.()]/, '');
        },
        "All phone numbers must be the same."
    );
            </pre>
            
            <hr />
            
            <h4 id="Distinct">Distinct:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").distinct( [transform], ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>transform</code>:  
                    Optional transform to apply to each value before testing. 
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Ensure that the values of all matched elements are distinct from 
                each other. In other words, validate that no value is repeated among 
                the matched elements.
            </p>
            
            <p>
                If any of the matched elements do not have a value that element will not be tested. 
            </p>

            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Find all the inputs meant to hold Vehicle Identification Numbers.
// Since every VIN should be different, a repeat should be treated as invaid.
$("input.vin").distinct("A VIN Number was repeated.");
            </pre>
            
            <pre class="prettyprint lang-js">
// We can also use a transform to normalize values.
// For instance, if we wish to ignore case 
// (i.e. if "abc" and "ABC" should be treated as a repeat)
// we can pass in a transform that makes all values upper-case.
// An example of this might be network interface hardware addresses.

// We'll allow the values to be in upper or lower case, 
// but treat those as the same value.
$("input.macAddress")
    .match(/([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}/, "Must be a valid MAC address.")
    .distinct(
        function(val) { 
            return val.toUpperCase();
        },
        "A hardware address was repeated."
    );
            </pre>
            
            <hr />
            
            <h4 id="Sum">Sum/Sum Max/Sum Min:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").sum( sum, ['message'] )</pre>
            <pre>jQuery("selector").sumMax( max, ['message'] )</pre>
            <pre>jQuery("selector").sumMin( min, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>sum</code>:  
                    The value that the sum of matched elements should be equal to. 
                </li>
                <li>
                    <code>max</code>:  
                    The <em>inclusive</em> upper-bound for the sum of matched elements 
                </li>
                <li>
                    <code>min</code>:  
                    The <em>inclusive</em> lower-bound for the sum of matched elements 
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                 Validate that the numeric sum of the value of all matched elements is 
                 equal to a given value or bounded by a specified max or min. If any 
                 value is not parseable as a number it will be ignored.
            </p>

            <h5>Examples:</h5>
            <pre class="prettyprint lang-js">
// Find inputs representing the three interior angles of a triangle.
$("input.triangleAngle")
  .require()
  .match("number")
  .sum(180, "A triangle's angles should add up to 180 degrees.");
            </pre>


            <pre class="prettyprint lang-js">
// Find inputs representing the how you intend to distribute 100,000 dollars among
// several people without having to distribute all of it.
$("input.distribution")
  .match("usd")
  .sumMax(100000, "You can't distribute more than you have on hand.");
            </pre>
            
            <hr />
            
            <h3 id="SpecializedValidation">Specialized Validation:</h3>
            
            <p>
                Validity supplies validator methods that cover the most common scenarios, but it
                also offers a tool to write your own custom validator with 'assert'.
            </p>
            
            <p>
                Assert is at once the most complicated and most capable validator in the validity suite.
                It's use is thoroughly outlined below.
            </p>
            
            <hr />
            
            <h4 id="Assert">Assert:</h4>
            
            <h5>Signature:</h5>
            <pre>jQuery("selector").assert( expression|function, ['message'] )</pre>
            
            <h5>Arguments:</h5>
            <ul>
                <li>
                    <code>expression</code>:  
                    Any expression that will result in a boolean. When expression evaluates
                    to true the validator succeeds. Keep in mind, when passing an expression
                    rather than a function, assert will act like an aggregate validator. That 
                    is to say, the truth or falsehood of expression will determine the 
                    validity of ALL matched elements.
                </li>
                <li>
                    <code>function</code>:  
                    A javascript function object which will accept a DOM Element and return
                    true or false representing whether that DOM element was valid. Keep in 
                    mind that when passing a function rather than an expression assert will
                    act like a common (non-aggregate) validator. That is to say that the 
                    function will be applied to each and every matched element and their 
                    validity is determined individually.
                </li>
                <li>
                    <code>message</code>:  
                    An optional message to display if an element fails. While this argument is
                    optional, it is strongly encouraged for use with the assert validator.
                </li>
            </ul>
            
            <h5>Overview:</h5>
            <p>
                Assert allows you to validate inputs using your own customized logic, but still 
                let validity display the error messages. If what you need is not provided among 
                validity's built-in validator methods, you can write it yourself with assert. 
                (In fact, any of the built in functions could be replicated with assert. It's that
                powerful.)
            </p>
            
            <p>
                There are two general ways to use assert: you can pass in an expression argument 
                (which evaluates into a boolean), or you can pass in a JavaScript function object. 
                It is important to understand that assert will act like an aggregate validator when
                an expression is passed, but will act like a common (non-aggregate) validator 
                when a function object is passed.
            </p>
            
            <h5>Examples:</h5>
            
            <p>
                To illustrate these techniques, we can write a validator to determine whether a
                set of inputs are all evens or all odds:
            </p>
            
            <pre class="prettyprint lang-js">
$(function() {
    $("form").validity(function() {
        // Store the information in local variables:
        // These are booleans:
        var allEvens = (
            parseFloat($("#box1").val()) % 2 == 0 &&
            parseFloat($("#box2").val()) % 2 == 0 &&
            parseFloat($("#box3").val()) % 2 == 0 &&
            parseFloat($("#box4").val()) % 2 == 0
        );
        var allOdds = (
            parseFloat($("#box1").val()) % 2 == 1 &&
            parseFloat($("#box2").val()) % 2 == 1 &&
            parseFloat($("#box3").val()) % 2 == 1 &&
            parseFloat($("#box4").val()) % 2 == 1
        );
        
        // Pass the OR of those two booleans as the expression argument into assert.
        // This will cause the inputs to be considered all valid or all invalid.
        $("#box1, #box2, #box3, #box4")
            .match("integer")
            .assert(
                (allEvens || allOdds), 
                "The inputs can either have all even numbers or all odd numbers. Not mixed."
            );
    });
});
            </pre>
            
            <p>
                As another example, we can pass a function object to perform common, 
                non-aggregate validation. In the below example we can individually
                determine whether any of the selected inputs is a palindrome:
            </p>
            
            <pre class="prettyprint lang-js">
// First create the functions that will be used in validation.
        
// Helper to reverse a string:
function reverse(s){
    var  r = "";
    var  l = s.length;
    for (var i = l; i > 0; i--){
        r += s.charAt(i-1)
    };
    return r ;
}

// Returns whether the value of the passed element is a palindrome:
// Notice that this function is meant to accept the DOM element, 
// not the value of the DOM element.
function isPalindrome(element){
    return element.value == reverse(element.value);
}
            
$(function() {
    $("form").validity(function() {
        // Instruct assert to use this function to test each input.
        // Notice that we're passing the function itself 
        // rather than the result of the function.
        // (i.e. "isPalindrome" not "isPalindrome()" )
        $(":text").assert(
            isPalindrome, 
            "#{field} must be a palindrome."
        );
    });
});
            </pre>

            <hr />
            
            <h2 id="TokenizedMessages">Tokenized Messages</h2>
            
            <p>
                Validity will attempt to generate helpful error messages based on how
                you validate what inputs. This feature is intended to minimize the number
                of error messages you'll be required to write yourself and to keep 
                validation messages consistent.
            </p>
            
            <p>
                Note: Validity will still grant you full control over the messages. You will
                not be forced to use this feature, although it will simplify your code in 
                most cases.
            </p>
            
            <hr />
            
            <h3 id="UnderstandingTokens">Understanding Tokenized Messages</h3>
            
            <p>
                The mechanism validity uses to generate these messages uses a library of 
                default message strings that contain tokens. For example, validity contains
                the following string as a default message for required field errors:
            </p>
            
            <pre class="prettyprint lang-js">
"#{field} is required."
            </pre>
            
            <p>
                The #{field} part at the beginning of the string is a token to be replaced with
                the title of the input for which the error is being created. In this way, a
                required field error being generated for an input titled "your name" will generate
                the message "Your name is required."
            </p>
            
            <p>
                Similary, the tokenized message for range validators is:
            </p>
            
            <pre class="prettyprint lang-js">
"#{field} must be between #{min} and #{max}."
            </pre>
            
            <p>
                As you can see, there are tokens for the min and the max so that those values can
                be inserted into the error message. An example result message might be: "Age of 
                car must be between 10 and 60."
            </p>
            
            <p>
                Because every validator method allows you to pass in your own validation message to
                override the default, you may use tokens when you do this. For instance, if you use
                the match validator with your own regular expression to validate multiple inputs you
                might use a tokenized message in the following way:
            </p>
            
            <pre class="prettyprint lang-js">
$("input.ssn").match(
    /^\d{3}-\d{2}-\d{4}$/, 
    "#{field} needs to be in the format of a Social Security Number."
);
            </pre>
            
            <p>
                In this way you can have validity generate several messages for each input. The above
                statement might generate the error messages: "Your SSN needs to be in the format of 
                a Social Security Number.", "Cosigner A SSN needs to be in the format of a Social Security 
                Number.", and "Cosigner B SSN needs to be in the format of a Social Security Number."
            </p>
            
            <p>
                Note: All default messages can be rewritten or modified to fit the parlance of your site.
                For information on how to do this refer to the <a href="#EditingMessages">Customizing 
                Messages</a> section later on in this document.
            </p>
            
            <hr />
            
            <h3 id="TokenPractices">Best Practices</h3>
            
            <p>
                A significant part of how Validity generates error messages involves figuring out what the 
                name of the input should be. Validity needs to guess the name of an input in order to insert 
                that into the #{field} token of a tokenized message. It is important to understand how Validity
                makes this guess in order that you can help it to guess correctly.
            </p>
            
            <ol>
                <li>
                    <p>
                        Validity will first look at the "title" attribute of an input. If an input has a title 
                        attribute Validity will assume that is its name. For example, if validity had to guess
                        the name of the following input it will assume that it's "User Name" because that is 
                        the value of the title attribute.
                    </p>
                    
                    <pre class="prettyprint lang-js">
&lt;input id="not_helpful" name="not_helpful" title="User Name" /&gt;
                    </pre>
                    
                    <p>
                        Using the title attribute in this way is the preferrable method. If you're able to
                        set the title attribute of an input, you're advised to do so this way.
                    </p>
                </li>
                <li>
                    <p>
                        Validity will next look at the "id" attribute of the element. If the id attribute appears 
                        to be in "Upper Camel Case" format (sometimes called Pascal Case)
                        it will take that value and split it into words by inserting a space before each capital letter.
                    </p>
                    
                    <p>
                        For example, if Validity had to guess the name of the following input, it will assume that it's
                        "User Name" because the value of the id attribute is in Upper Camel Case form and there is
                        no "title" attribute.
                    </p>
                    
                    <pre class="prettyprint lang-js">
&lt;input id="UserName" name="UserName" /&gt;
                    </pre>
                </li>
                
                <li>
                    <p>
                        If the previous two checks have failed, Validity will check whether the id is in the form
                        of lower-case words separated by underscores. If Validity finds this format, it will replace
                        each underscore with a space and capitalize the first letter of each word.
                    </p>
                    
                    <p>
                        For example, Validity would assume the that name for the following input is "User Name".
                    </p>
                    
                    <pre class="prettyprint lang-js">
&lt;input id="user_name" name="user_name" /&gt;
                    </pre>
                </li>
                
                <li>
                    <p>
                        If Validity has failed the previous three tests, it will use a default field name which is 
                        built-in. This default name is:
                    </p>
                    
                    <pre class="prettyprint lang-js">
defaultFieldName: "This field"
                    </pre>
                    
                    <p>
                        Often, if Validity ends up using the default field 
                        name, the error messages will still be helpful and natural-looking because, with the label and 
                        modal output modes at least, error messages are positioned right next to the input to which they
                        refer.
                    </p>
                </li>
                
                <li>
                    <p>
                        Lastly, if you are not able to set the title attribute or do not have the ability to give your 
                        inputs meaningful ids and you don't wish the default field name to be used, you can always pass 
                        a specific non-tokenized string of your message into the validator call. Each and every validator 
                        will accept a string as its last argument to be used as the message.
                    </p>
                </li>
            </ol>
        
            <hr />
            
            <h2 id="OutputModes">Output Modes</h2>
            
            <p>
                Although Validity is able to validate inputs, its other role is to display errors appropriately and 
                consistently. The logic that Validity uses to display error is wrapped up into what's called an output
                mode. There are three output modes included with validity, each of which are summarized here.
            </p>
            
            <p>
                You are also able to write your own output mode and get full control to how messages are displayed.
                For a full explanation of how to do this see the <a href="#CustomOutputMode">Writing a Custom Output 
                Mode</a> section later in this document.
            </p>
            
            <p>
                You may instruct Validity which output mode you would like to use with the setup function. For example,
                to enable the "summary" output mode, the following code would be appropriate:
            </p>
            
            <pre class="prettyprint lang-js">
$.validity.setup({ outputMode:"summary" });
            </pre>
            
            <hr  />
            
            <h3 id="Label">Label</h3>
            
            <p>
                Label is the default output mode in Validity. If you do not specify another output mode using the setup
                function, label will be what is used.
            </p>
            
            <p>
                When this output mode is to create an error message, it will create an HTML label element with the CSS 
                class "error", the "for" attribute set to the id of the input it is being created for and the text of 
                the error message. This label element is then positioned after the input it has been created for.
            </p>
            
            <p>
                The advantage of this output mode is that it will place error messages very helpfully next to the offending
                inputs. Additionally, it does not require anything to be setup in advance aside from its CSS styles.
            </p>
            
            <hr  />
            
            <h3 id="Modal">Modal</h3>
            
            <p>
                blah
            </p>
            
            <hr  />
            
            <h3 id="Summary">Summary</h3>
            
            <p>
                blah blah
            </p>
            
            <hr  />
        </div>
        <span id="scrollback">
            [<a href="#">Scroll back to the top</a>]
        </span>
    </body>
</html>
